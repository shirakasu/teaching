# SOLID原則

SOLID原則とは、オブジェクト指向設計において「変更に強く、理解しやすく、再利用性の高い」ソフトウェアを作るための5つの基本原則です。

---

## S: Single Responsibility (単一責任の原則)
> **「クラスを変更する理由は、たったひとつであるべきである」**

1つのクラスに複数の役割（責任）があると、一方の変更が他方に予期せぬ影響を与えます。「誰（どの部門）からの要望でこのコードを変更するか？」を考えると責任を分離しやすくなります。

- **悪い例:** `Report` クラスが「計算」と「印刷（フォーマット）」の両方を知っている。
- **良い例:** 計算ロジックと、出力を担当するクラスを分ける。


```java
// 良い例：役割ごとに分離
class ReportCalculator {
    public function calculate() { /* 数値計算に専念 */ }
}

class ReportPrinter {
    public function print($data) { /* 表示・印刷に専念 */ }
}

```

---

## O: Open-Closed (オープン・クローズドの原則)

> **「拡張に対して開いており、修正に対して閉じているべきである」**

新機能を追加する際に、**「既存のソースコードを書き換える（修正）」のではなく、「新しいコードを追加する（拡張）」**だけで済むように設計します。

* **悪い例:** 新しい図形が増えるたびに、描画クラスの `if` 文や `switch` 文を書き換える。
* **良い例:** インターフェースや継承（ポリモーフィズム）を使い、描画クラス側は変更不要にする。

```java
interface Shape {
    public function draw();
}

// 新しい図形が増えても、Shapeを実装した新クラスを作るだけで既存コードは壊れない
class Triangle implements Shape {
    public function draw() { /* 三角形の描画 */ }
}

```

---

## L: Liskov Substitution (リスコフの置換原則)

> **「子クラスは、親クラスといつでも置き換え可能でなければならない」**

子クラスは、親クラスが定義した「期待される振る舞い（契約）」を壊してはいけません。親クラスでできることが子クラスでエラーになる場合、それは継承の使い方が不適切です。

* **悪い例:** 「鳥」クラスを継承した「ペンギン」クラスが、`fly()` メソッドで例外を投げる。（クライアント側は鳥なら飛べるはずだと期待しているため）
* **良い例:** 「飛べる鳥」と「歩く鳥」をインターフェースで正しく分類する。

---

## I: Interface Segregation (インターフェース分離の原則)

> **「利用しないメソッドへの依存を、クライアントに強制してはならない」**

何でもできる巨大なインターフェース（Fat Interface）を作るのではなく、必要最小限の機能に絞った小さなインターフェースに分割します。

* **悪い例:** 「印刷・スキャン・FAX」が1つのインターフェースにある。印刷しかしないクラスもFAXの実装を強制される。
* **良い例:** `Printer`、`Scanner`、`Fax` インターフェースに分ける。

```java
// 良い例：必要な機能だけを組み合わせて使う
class SimplePrinter implements Printer {
    public function print() { /* 印刷のみ実装 */ }
}

```

---

## D: Dependency Inversion (依存性逆転の原則)

> **「上位のモジュールは下位のモジュールに依存してはならない。両者は抽象に依存すべきである」**

具体的な実装（MySQL、特定のAPIなど）に依存するのではなく、抽象（インターフェース）に依存させることで、部品の差し替えを容易にします。

* **悪い例:** `OrderService` が `MySQLDatabase` クラスを直接 `new` している。
* **良い例:** `OrderService` は `Database` インターフェースを要求し、実行時に具体的なDB（MySQLやPostgreSQL）を注入（Dependency Injection）する。

```java
class OrderService {
    private $db;

    // 具体的なDBではなく「インターフェース」を受け取る（依存性の注入）
    public function __construct(Database $db) {
        $this->db = $db;
    }
}

```

---

## まとめ：なぜSOLID原則を守るのか？

1. **保守性:** 修正時の影響範囲が特定しやすくなる。
2. **可読性:** クラスの目的が明確になり、コードが読みやすくなる。
3. **テスト容易性:** 依存関係が整理され、ユニットテストが書きやすくなる。

すべてを厳密に守ろうとすると設計が複雑になりすぎることもあります。まずは **「S (単一責任)」** と **「D (依存性逆転)」** から意識し始め、コードの柔軟性を実感してみるのが上達の近道です。
